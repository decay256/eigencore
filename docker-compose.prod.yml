# =============================================================================
# Eigencore Production Docker Compose
# =============================================================================
# Production setup with:
# - Caddy reverse proxy (automatic HTTPS + serves frontend)
# - Multiple API instances (load balanced)
# - External/managed Postgres (not included here)
#
# Usage:
#   docker compose -f docker-compose.prod.yml up -d
#
# Prerequisites:
#   - Point your domain's DNS to this server
#   - Update Caddyfile with your actual domain
#   - Set DATABASE_URL in .env to your managed Postgres
#   - Configure OAuth redirect URIs for your domain
# =============================================================================

services:
  # ---------------------------------------------------------------------------
  # Caddy Reverse Proxy + Frontend
  # ---------------------------------------------------------------------------
  # Serves static frontend files and proxies API requests to backend.
  # Automatic HTTPS via Let's Encrypt.
  
  caddy:
    image: caddy:2-alpine
    container_name: eigencore-caddy
    ports:
      - "80:80"       # HTTP (redirects to HTTPS)
      - "443:443"     # HTTPS
    volumes:
      - ./Caddyfile:/etc/caddy/Caddyfile:ro   # Caddy config
      - ./frontend:/srv/frontend:ro            # Frontend static files
      - caddy_data:/data                       # Certificates
      - caddy_config:/config                   # Caddy state
    depends_on:
      - api
    restart: unless-stopped

  # ---------------------------------------------------------------------------
  # Eigencore API (Production)
  # ---------------------------------------------------------------------------
  # Multiple instances for HA and load distribution.
  # Caddy load balances between them automatically.
  
  api:
    build:
      context: .
      dockerfile: Dockerfile
    env_file:
      - .env
    environment:
      DEBUG: "false"
    
    expose:
      - "8000"
    
    deploy:
      replicas: 2
      resources:
        limits:
          memory: 512M
        reservations:
          memory: 256M
    
    restart: unless-stopped
    
    healthcheck:
      test: ["CMD", "python", "-c", "import urllib.request; urllib.request.urlopen('http://localhost:8000/health')"]
      interval: 30s
      timeout: 10s
      retries: 3


volumes:
  caddy_data:
  caddy_config:


# =============================================================================
# Scaling Notes
# =============================================================================
#
# Scale API instances:
#   docker compose -f docker-compose.prod.yml up -d --scale api=5
#
# Monitor:
#   docker compose -f docker-compose.prod.yml ps
#   docker compose -f docker-compose.prod.yml logs -f api
#
# For 10k concurrent users:
#   - 4-6 API instances (2GB each)
#   - Managed Postgres with connection pooling
#   - Redis for WebSocket pub/sub (room sync across instances)
# =============================================================================
